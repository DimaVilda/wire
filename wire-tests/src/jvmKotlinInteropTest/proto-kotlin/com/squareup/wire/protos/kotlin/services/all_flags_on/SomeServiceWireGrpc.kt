// Code generated by Wire protocol buffer compiler, do not edit.
// Source: squareup.protos.kotlin.SomeService in service_kotlin_with_all_flags.proto
package com.squareup.wire.protos.kotlin.services.all_flags_on

import com.google.protobuf.DescriptorProtos
import com.google.protobuf.Descriptors
import com.squareup.wire.kotlin.grpcserver.WireBindableService
import com.squareup.wire.kotlin.grpcserver.WireMethodMarshaller
import io.grpc.CallOptions
import io.grpc.Channel
import io.grpc.MethodDescriptor
import io.grpc.ServerServiceDefinition
import io.grpc.ServiceDescriptor
import io.grpc.ServiceDescriptor.newBuilder
import io.grpc.stub.AbstractStub
import io.grpc.stub.ClientCalls.blockingUnaryCall
import io.grpc.stub.StreamObserver
import java.io.InputStream
import java.lang.Class
import java.lang.UnsupportedOperationException
import java.util.concurrent.ExecutorService
import kotlin.Array
import kotlin.String
import kotlin.Unit
import kotlin.collections.Map
import kotlin.collections.Set
import kotlin.jvm.Volatile
import io.grpc.stub.ClientCalls.asyncUnaryCall as clientCallsAsyncUnaryCall
import io.grpc.stub.ServerCalls.asyncUnaryCall as serverCallsAsyncUnaryCall

public object SomeServiceWireGrpc {
  public val SERVICE_NAME: String = "squareup.protos.kotlin.SomeService"

  @Volatile
  private var serviceDescriptor: ServiceDescriptor? = null

  private val descriptorMap: Map<String, DescriptorProtos.FileDescriptorProto> = mapOf(
    "service_kotlin_with_all_flags.proto" to descriptorFor(arrayOf(
      "CiNzZXJ2aWNlX2tvdGxpbl93aXRoX2FsbF9mbGFncy5wcm90bxIWc3F1YXJldXAucHJvdG9zLmtvdGxp",
      "biINCgtTb21lUmVxdWVzdCIOCgxTb21lUmVzcG9uc2UyZgoLU29tZVNlcnZpY2USVwoKU29tZU1ldGhv",
      "ZBIjLnNxdWFyZXVwLnByb3Rvcy5rb3RsaW4uU29tZVJlcXVlc3QaJC5zcXVhcmV1cC5wcm90b3Mua290",
      "bGluLlNvbWVSZXNwb25zZUI3CjVjb20uc3F1YXJldXAud2lyZS5wcm90b3Mua290bGluLnNlcnZpY2Vz",
      "LmFsbF9mbGFnc19vbg==",
    )),
  )


  @Volatile
  private var getSomeMethodMethod: MethodDescriptor<SomeRequest, SomeResponse>? = null

  private fun descriptorFor(`data`: Array<String>): DescriptorProtos.FileDescriptorProto {
    val str = data.fold(java.lang.StringBuilder()) { b, s -> b.append(s) }.toString()
    val bytes = java.util.Base64.getDecoder().decode(str)
    return DescriptorProtos.FileDescriptorProto.parseFrom(bytes)
  }

  private fun fileDescriptor(path: String, visited: Set<String>): Descriptors.FileDescriptor {
    val proto = descriptorMap[path]!!
    val deps = proto.dependencyList.filter { !visited.contains(it) }.map { fileDescriptor(it,
        visited + path) }
    return Descriptors.FileDescriptor.buildFrom(proto, deps.toTypedArray())
  }

  public fun getServiceDescriptor(): ServiceDescriptor? {
    var result = serviceDescriptor
    if (result == null) {
      synchronized(SomeServiceWireGrpc::class) {
        result = serviceDescriptor
        if (result == null) {
          result = newBuilder(SERVICE_NAME)
          .addMethod(getSomeMethodMethod())
          .setSchemaDescriptor(io.grpc.protobuf.ProtoFileDescriptorSupplier {
                fileDescriptor("service_kotlin_with_all_flags.proto", emptySet())
              })
          .build()
          serviceDescriptor = result
        }
      }
    }
    return result
  }

  public fun getSomeMethodMethod(): MethodDescriptor<SomeRequest, SomeResponse> {
    var result: MethodDescriptor<SomeRequest, SomeResponse>? = getSomeMethodMethod
    if (result == null) {
      synchronized(SomeServiceWireGrpc::class) {
        result = getSomeMethodMethod
        if (result == null) {
          getSomeMethodMethod = MethodDescriptor.newBuilder<SomeRequest, SomeResponse>()
            .setType(MethodDescriptor.MethodType.UNARY)
            .setFullMethodName(
              MethodDescriptor.generateFullMethodName(
                "squareup.protos.kotlin.SomeService", "SomeMethod"
              )
            )
            .setSampledToLocalTracing(true)
            .setRequestMarshaller(SomeServiceImplBase.SomeRequestMarshaller())
            .setResponseMarshaller(SomeServiceImplBase.SomeResponseMarshaller())
            .build()
        }
      }
    }
    return getSomeMethodMethod!!
  }

  public fun newStub(channel: Channel): SomeServiceStub = SomeServiceStub(channel)

  public fun newBlockingStub(channel: Channel): SomeServiceBlockingStub =
      SomeServiceBlockingStub(channel)

  public abstract class SomeServiceImplBase : WireBindableService {
    public open fun SomeMethod(request: SomeRequest, response: StreamObserver<SomeResponse>): Unit =
        throw UnsupportedOperationException()

    override fun bindService(): ServerServiceDefinition =
        ServerServiceDefinition.builder(getServiceDescriptor()).addMethod(
              getSomeMethodMethod(),
              serverCallsAsyncUnaryCall(this@SomeServiceImplBase::SomeMethod)
            ).build()

    public class SomeRequestMarshaller : WireMethodMarshaller<SomeRequest> {
      override fun stream(`value`: SomeRequest): InputStream =
          SomeRequest.ADAPTER.encode(value).inputStream()

      override fun marshalledClass(): Class<SomeRequest> = SomeRequest::class.java

      override fun parse(stream: InputStream): SomeRequest = SomeRequest.ADAPTER.decode(stream)
    }

    public class SomeResponseMarshaller : WireMethodMarshaller<SomeResponse> {
      override fun stream(`value`: SomeResponse): InputStream =
          SomeResponse.ADAPTER.encode(value).inputStream()

      override fun marshalledClass(): Class<SomeResponse> = SomeResponse::class.java

      override fun parse(stream: InputStream): SomeResponse = SomeResponse.ADAPTER.decode(stream)
    }
  }

  public class BindableAdapter(
    private val streamExecutor: ExecutorService,
    private val SomeMethod: () -> SomeServiceSomeMethodBlockingServer,
  ) : SomeServiceImplBase() {
    override fun SomeMethod(request: SomeRequest, response: StreamObserver<SomeResponse>) {
      response.onNext(SomeMethod().SomeMethod(request))
      response.onCompleted()
    }
  }

  public class SomeServiceStub : AbstractStub<SomeServiceStub> {
    internal constructor(channel: Channel) : super(channel)

    internal constructor(channel: Channel, callOptions: CallOptions) : super(channel, callOptions)

    override fun build(channel: Channel, callOptions: CallOptions): SomeServiceStub =
        SomeServiceStub(channel, callOptions)

    public fun SomeMethod(request: SomeRequest, response: StreamObserver<SomeResponse>) {
      clientCallsAsyncUnaryCall(channel.newCall(getSomeMethodMethod(), callOptions), request,
          response)
    }
  }

  public class SomeServiceBlockingStub : AbstractStub<SomeServiceStub> {
    internal constructor(channel: Channel) : super(channel)

    internal constructor(channel: Channel, callOptions: CallOptions) : super(channel, callOptions)

    override fun build(channel: Channel, callOptions: CallOptions): SomeServiceStub =
        SomeServiceStub(channel, callOptions)

    public fun SomeMethod(request: SomeRequest): SomeResponse = blockingUnaryCall(channel,
        getSomeMethodMethod(), callOptions, request)
  }
}
